local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")
local RunService = game:GetService("RunService")

local parryRemote = VirtualUser:WaitForChild("\n\n\n\n\n\n\n\n\n\n")
local player = Players.LocalPlayer
local parried = false

local Vanta = {
    AutoParry = {
        Enabled = true,
        ReactionMultiplier = 2.7,
        ParryRangeMultiplier = 1.6, 
    },
}

local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
local ballSpeedLabel = Instance.new("TextLabel", screenGui)
ballSpeedLabel.Size = UDim2.new(0, 200, 0, 50)
ballSpeedLabel.Position = UDim2.new(0, 0, 0, 0)
ballSpeedLabel.TextScaled = true
ballSpeedLabel.BackgroundTransparency = 1
ballSpeedLabel.TextColor3 = Color3.fromRGB(0, 255, 21)
ballSpeedLabel.Text = "Ball Speed: 0"

local function GetBall()
    for index, ball in next, workspace.Balls:GetChildren() do
        if ball:GetAttribute("realBall") then
            return ball
        end
    end
    return nil
end

local function parry()
    local cameraPosition = workspace.CurrentCamera.CFrame.Position
    local randomPosition = Vector3.new(math.random(-1000, 1000), math.random(0, 1000), math.random(100, 1000))
    local targetCFrame = CFrame.new(cameraPosition, randomPosition)

    local args = {
        [1] = 0,
        [2] = targetCFrame,
        [3] = {},
        [4] = {
            [1] = workspace.CurrentCamera.ViewportSize.X / 2,
            [2] = workspace.CurrentCamera.ViewportSize.Y / 2
        },
        [5] = true
    }

    parryRemote:FireServer(unpack(args))
end

local function isCurved(ball, target)
    if not target then
        return false
    end

    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        speedThreshold = 300,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isTargeted(ball)
    local target = ball:GetAttribute("target")
    return target == tostring(player)
end

local function isCurvedLeft(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isCurvedRight(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isCurvedUp(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isCurvedDown(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function calculateReactionTime(ballSpeed)
    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local reactionTime = 0.1 + (ballSpeed / 150) + playerPing
    return reactionTime * Vanta.AutoParry.ReactionMultiplier
end

local function adjustParryRange(ballSpeed)
    local parryRange = 15 + (ballSpeed / 7.5)
    return parryRange * Vanta.AutoParry.ParryRangeMultiplier
end

RunService.Heartbeat:Connect(function()
    local ball = GetBall()
    if ball then
        if isTargeted(ball) and not parried then
            local distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude
            local velocity = ball.AssemblyLinearVelocity
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
            local ballSpeed = velocity.Magnitude
            local accuracy = adjustParryRange(ballSpeed)

            ballSpeedLabel.Text = "Ball Speed: " .. math.floor(ballSpeed)

            if Vanta.AutoParry.Enabled and distance <= accuracy then
                if ballSpeed < 300 then
                    if isCurved(ball, isTargeted(ball)) or isCurvedLeft(ball) or isCurvedRight(ball) then
                        task.wait(0.25)
                    end
                end
                local reactionTime = calculateReactionTime(ballSpeed)
                parry()
                parried = true

                ball:GetAttributeChangedSignal("target"):Connect(function()
                    parried = false
                end)

                local oldTick = tick()
                repeat
                    RunService.PreRender:Wait()
                until (tick() - oldTick) >= 1 or not parried

                parried = false
            end
        end
    end
end)

local parryInterval = 0.1

local function autoParryTask()
    local ball = GetBall()
    if ball then
        if isTargeted(ball) and not parried then
            local distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude
            local velocity = ball.AssemblyLinearVelocity
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
            local ballSpeed = velocity.Magnitude
            local accuracy = adjustParryRange(ballSpeed)

            ballSpeedLabel.Text = "Ball Speed: " .. math.floor(ballSpeed)

            if Vanta.AutoParry.Enabled and distance <= accuracy then
                if ballSpeed < 300 then
                    if isCurved(ball, isTargeted(ball)) or isCurvedLeft(ball) or isCurvedRight(ball) then
                        task.wait(0.25)
                    end
                end
                local reactionTime = calculateReactionTime(ballSpeed)
                parry()
                parried = true

                ball:GetAttributeChangedSignal("target"):Connect(function()
                    parried = false
                end)

                local oldTick = tick()
                repeat
                    RunService.PreRender:Wait()
                until (tick() - oldTick) >= 1 or not parried

                parried = false
            end
        end
    end
    task.wait(parryInterval)
end
autoParryTask()

local NothingLibrary = loadstring(game:HttpGetAsync('https://raw.githubusercontent.com/3345-c-a-t-s-u-s/NOTHING/main/source.lua'))();
local Notification = NothingLibrary.Notification();

Notification.new({
    Title = "Official Discord Serverâ›…",
    Description = "https://discord.com/invite/PvZX8BJKbS",
    Duration = 5,
    Icon = "rbxassetid://8997385628"
})

local Windows = NothingLibrary.new({
    Title = "WaverHubâ›…",
    Description = "Made By Josh",
    Keybind = Enum.KeyCode.LeftControl,
    Logo = 'http://www.roblox.com/asset/?id=117922950166645'
})

local TabFrame = Windows:NewTab({
    Title = "Combat",
    Description = "Auto Parry/Auto Spam Etc",
    Icon = "rbxassetid://7733960981"
})

local Section = TabFrame:NewSection({
    Title = "Auto Parry/Auto Spam",
    Icon = "rbxassetid://7743869054",
    Position = "Left"
})

local InfoSection = TabFrame:NewSection({
    Title = "Information",
    Icon = "rbxassetid://7733964719",
    Position = "Right"
})

Section:NewToggle({
    Title = "Toggle",
    Default = false,
    Callback = function(tr)
         Vanta.AutoParry.Enabled = tr
    end,
})

InfoSection:NewTitle('Official Discord Server')
InfoSection:NewButton({

    Title = "Discord",
    Callback = function()
        print('https://discord.com/invite/PvZX8BJKbS')
    end,
})