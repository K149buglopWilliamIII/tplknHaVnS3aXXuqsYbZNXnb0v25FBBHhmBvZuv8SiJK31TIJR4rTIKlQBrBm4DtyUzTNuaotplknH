local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")
local RunService = game:GetService("RunService")

local Nurysium_Util = loadstring(game:HttpGet("https://raw.githubusercontent.com/flezzpe/Nurysium/main/nurysium_helper.lua"))()

local parryRemote = VirtualUser:WaitForChild("\n\n\n\n\n\n\n\n\n\n")
local player = Players.LocalPlayer
local parried = false

local Vanta = {
    AutoParry = {
        Enabled = true,
        ReactionMultiplier = 2.7,
        ParryRangeMultiplier = 1.9,
    },
    AutoSpam = {
        Enabled = true,
        Threshold = 10,
        Interval = 0.05,
    },
}

local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
screenGui.ResetOnSpawn = false
local ballSpeedLabel = Instance.new("TextLabel", screenGui)
ballSpeedLabel.Size = UDim2.new(0, 200, 0, 50)
ballSpeedLabel.Position = UDim2.new(0, 0, 0, 0)
ballSpeedLabel.TextScaled = true
ballSpeedLabel.BackgroundTransparency = 1
ballSpeedLabel.TextColor3 = Color3.fromRGB(0, 255, 21)
ballSpeedLabel.Text = "Ball Speed: 0"


local function GetBall()
    for index, ball in next, workspace.Balls:GetChildren() do
        if ball:GetAttribute("realBall") then
            return ball
        end
    end
    return nil
end

local function parry()
    local cameraPosition = workspace.CurrentCamera.CFrame.Position
    local randomPosition = Vector3.new(math.random(-1000, 1000), math.random(0, 1000), math.random(100, 1000))
    local targetCFrame = CFrame.new(cameraPosition, randomPosition)

    local args = {
        [1] = 0,
        [2] = targetCFrame,
        [3] = {},
        [4] = {
            [1] = workspace.CurrentCamera.ViewportSize.X / 2,
            [2] = workspace.CurrentCamera.ViewportSize.Y / 2
        },
        [5] = true
    }

    parryRemote:FireServer(unpack(args))
end

local function isCurved(ball, target)
    if not target then
        return false
    end

    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        speedThreshold = 300,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isTargeted(ball)
    local target = ball:GetAttribute("target")
    return target == tostring(player)
end

local function isCurvedLeft(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isCurvedRight(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isCurvedUp(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isCurvedDown(ball)
    local ballProperties = {
        distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude,
        speed = ball.AssemblyLinearVelocity.Magnitude,
        velocity = ball.AssemblyLinearVelocity,
        dot = ball.CFrame.LookVector:Dot(ball.AssemblyLinearVelocity.Unit),
        maximumSpeed = ball.AssemblyLinearVelocity.Magnitude,
        aeroDynamicTime = 0,
        lastCurvePosition = Vector3.new(),
        lastWarping = 0
    }

    if ball:FindFirstChild('MaxShield') or ball:FindFirstChild('TimeHole1') or ball:FindFirstChild('WEMAZOOKIEGO') then
        return false
    end

    if ball:FindFirstChild('At2') and ballProperties.speed <= 0 then
        return true
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        game:GetService("Debris"):AddItem(ball.AeroDynamicSlashVFX, 0)
        ballProperties.aeroDynamicTime = tick()
        return false
    end

    if workspace:FindFirstChild('Tornado') then
        local tornadoTime = workspace.Tornado:GetAttribute("TornadoTime") or 1
        if ballProperties.distance > 5 and (tick() - ballProperties.aeroDynamicTime) < (tornadoTime + 0.314159) then
            return true
        end
    end

    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local ballDirection = ballProperties.velocity.Unit
    local speedThreshold = math.min(ballProperties.speed / 100, 60)
    local angleThreshold = 60 * math.max(ballProperties.dot, 0)

    local accurateDirection = ballProperties.velocity.Unit * ballDirection
    local directionDifference = (accurateDirection - ballProperties.velocity).Unit
    local accurateDot = ballDirection:Dot(directionDifference)
    local dotDifference = ballProperties.dot - accurateDot
    local dotThreshold = 0.5 - playerPing

    local reachTime = ballProperties.distance / ballProperties.maximumSpeed - playerPing
    local enoughSpeed = ballProperties.maximumSpeed > 200
    local ballDistanceThreshold = 15 - math.min(ballProperties.distance / 1000, 15) + angleThreshold + speedThreshold

    if enoughSpeed and reachTime > playerPing / 10 then
        ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
    end

    if ballProperties.distance < ballDistanceThreshold then
        return false
    end

    if dotDifference < dotThreshold then
        return true
    end

    if ballProperties.lerpRadians and ballProperties.lerpRadians < 0.018 then
        ballProperties.lastCurvePosition = ball.Position
        ballProperties.lastWarping = tick()
    end

    if (tick() - ballProperties.lastWarping) < (reachTime / 1.5) then
        return true
    end

    return ballProperties.dot < dotThreshold
end

local function isVulnerable(player)
    local character = player.Character
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return false end

    local runService = game:GetService("RunService")
    local playerAnimations = require(game:GetService("ReplicatedStorage").PlayerAnimations)
    local animation = playerAnimations:FindFirstChild(player.Name)

    if animation then
        local animationState = animation:FindFirstChild(humanoid.Name)
        if animationState then
            local state = animationState:FindFirstChild("State")
            if state then
                local stateName = state.Value
                if stateName == "Jump" or stateName == "Fall" or stateName == "Swing" then
                    return false
                end
            end
        end
    end

    return true
end

local function isFacingBall(player, ball)
    local character = player.Character
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end

    local ballPosition = ball.Position
    local playerDirection = (ballPosition - humanoidRootPart.Position).Unit
    local playerForward = humanoidRootPart.CFrame.LookVector

    return playerDirection.X > -0.5 and playerDirection.X < 0.5 and playerDirection.Z > -0.5 and playerDirection.Z < 0.5 and playerForward.Y > 0.5
end

local function isBallMovingTowards(ball)
    local ballPosition = ball.Position
    local playerPosition = player.Character.HumanoidRootPart.Position
    local ballDirection = (ballPosition - playerPosition).Unit
    local playerForward = player.Character.HumanoidRootPart.CFrame.LookVector

    return ballDirection.X > -0.5 and ballDirection.X < 0.5 and ballDirection.Z > -0.5 and ballDirection.Z < 0.5 and playerForward.Y > 0.5
end

local function calculateReactionTime(ballSpeed)
    local playerPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local reactionTime = 0.1 + (ballSpeed / 100) + playerPing
    if ballSpeed > 300 then
        reactionTime = reactionTime * 0.8
    end
    if ballSpeed > 400 then
        reactionTime = reactionTime * 0.6
    end
    if ballSpeed > 500 then
        reactionTime = reactionTime * 0.4
    end
    return reactionTime * Vanta.AutoParry.ReactionMultiplier
end

local function adjustParryRange(ballSpeed)
    local parryRange = 15 + (ballSpeed / 7.5)
    if ballSpeed > 300 then
        parryRange = parryRange * 1.5
    end
    if ballSpeed > 400 then
        parryRange = parryRange * 2
    end
    if ballSpeed > 500 then
        parryRange = parryRange * 2.5
    end
    return parryRange * Vanta.AutoParry.ParryRangeMultiplier
end

local function predictParryPosition(ball_Position, ball_Velocity, ping)
	local predicted_Target_Position = ball_Position + (ball_Velocity * (ping / 100))
	return predicted_Target_Position
end

local aura = {
    hit_Count = 2,
    is_spamming = false,
}

local autoSpam_Threshold = Vanta.AutoSpam.Threshold
local speed_Check_Interval = Vanta.AutoSpam.Interval

local function updateAutoSpamBasedOnSpeedAndDistance()
    local self = Nurysium_Util.getBall()
    if not self then
        return
    end

    local ball_Velocity = self.AssemblyLinearVelocity
    local ball_Speed = ball_Velocity.Magnitude
    local ball_Distance = (local_player.Character.PrimaryPart.Position - ball_Position).Magnitude

    local min_Speed_Threshold = 20
    local min_Distance_Threshold = 10

    if ball_Speed > min_Speed_Threshold and ball_Distance < min_Distance_Threshold then
        aura.is_spamming = true
    else
        aura.is_spamming = false
    end
end

local function autoSpamReacts()
    local self = Nurysium_Util.getBall()
    if not self or not getgenv().autoReact_Enabled then return end

    local ball_Velocity = self.AssemblyLinearVelocity
    local ball_Speed = ball_Velocity.Magnitude
    local ball_Direction = ball_Velocity.Unit

    local curvature = math.abs(ball_Velocity.Unit:Dot(camera.CFrame.LookVector))

    if curvature > 0.5 then
        aura.is_spamming = true
    end
end

task.spawn(function()
    while true do
        if getgenv().autoSpam_Enabled then
            updateAutoSpamBasedOnSpeedAndDistance()
            autoSpamReacts() -- Call the auto react function

            local hit_Count = aura.hit_Count
            local hit_Threshold = 2

            if hit_Count > hit_Threshold then
                aura.is_spamming = true
            end

            local self = Nurysium_Util.getBall()
            if self then
                updateVisualizerSize(self.AssemblyLinearVelocity.Magnitude)
            end
        end
        task.wait(speed_Check_Interval)
    end
end)

local function spamParry()
    if aura.is_spamming then
        parry()
    end
end

RunService.Heartbeat:Connect(function()
    local ball = GetBall()
    if ball then
        if isTargeted(ball) and not parried then
            local distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude
            local velocity = ball.AssemblyLinearVelocity
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
            local ballSpeed = velocity.Magnitude
            local accuracy = adjustParryRange(ballSpeed)

            ballSpeedLabel.Text = "Ball Speed: " .. math.floor(ballSpeed)

            if Vanta.AutoParry.Enabled and distance <= accuracy then
                if ballSpeed < 300 then
                    if isCurved(ball, isTargeted(ball)) or isCurvedLeft(ball) or isCurvedRight(ball) then
                        task.wait(0.25)
                    end
                end
                local reactionTime = calculateReactionTime(ballSpeed)
                parry()
                parried = true

                ball:GetAttributeChangedSignal("target"):Connect(function()
                    parried = false
                end)

                local oldTick = tick()
                repeat
                    RunService.PreRender:Wait()
                until (tick() - oldTick) >= 1 or not parried

                parried = false
            end
        end
    end
    spamParry()
end)

local parryInterval = 0.1

local function autoParryTask()
    local ball = GetBall()
    if ball then
        if isTargeted(ball) and not parried and isVulnerable(player) and isFacingBall(ball, player) and isBallMovingTowards(ball) then
            local distance = (ball.Position - player.Character.HumanoidRootPart.Position).Magnitude
            local velocity = ball.AssemblyLinearVelocity
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
            local ballSpeed = velocity.Magnitude
            local accuracy = adjustParryRange(ballSpeed)

            ballSpeedLabel.Text = "Ball Speed: " .. math.floor(ballSpeed)

            if Vanta.AutoParry.Enabled and distance <= accuracy then
                if ballSpeed < 300 then
                    if isCurved(ball, isTargeted(ball)) or isCurvedLeft(ball) or isCurvedRight(ball) then
                        task.wait(0.25)
                    end
                end
                local reactionTime = calculateReactionTime(ballSpeed)
                parry()
                parried = true

                ball:GetAttributeChangedSignal("target"):Connect(function()
                    parried = false
                end)

                local oldTick = tick()
                repeat
                    RunService.PreRender:Wait()
                until (tick() - oldTick) >= 1 or not parried

                parried = false
            end
        end
    end
    task.wait(parryInterval)
end

local autoParryTaskHandle = task.spawn(autoParryTask)

local function toggleAutoParry()
    if Vanta.AutoParry.Enabled then
        Vanta.AutoParry.Enabled = false
        autoParryTaskHandle:cancel()
    else
        Vanta.AutoParry.Enabled = true
        autoParryTaskHandle = task.spawn(autoParryTask)
    end
end